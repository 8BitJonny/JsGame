/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./config.json":
/*!*********************!*\
  !*** ./config.json ***!
  \*********************/
/*! exports provided: clientVersion, default */
/***/ (function(module) {

eval("module.exports = {\"clientVersion\":\"0.1.0\"};\n\n//# sourceURL=webpack:///./config.json?");

/***/ }),

/***/ "./img/BODY_skeleton.png":
/*!*******************************!*\
  !*** ./img/BODY_skeleton.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"images/8a592a26be017c4deb54d55a28f4a2f6-BODY_skeleton.png\";\n\n//# sourceURL=webpack:///./img/BODY_skeleton.png?");

/***/ }),

/***/ "./img/Charakter01.png":
/*!*****************************!*\
  !*** ./img/Charakter01.png ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"\n\n//# sourceURL=webpack:///./img/Charakter01.png?");

/***/ }),

/***/ "./img/Testmap.json":
/*!**************************!*\
  !*** ./img/Testmap.json ***!
  \**************************/
/*! exports provided: height, infinite, layers, nextlayerid, nextobjectid, orientation, renderorder, tiledversion, tileheight, tilesets, tilewidth, type, version, width, default */
/***/ (function(module) {

eval("module.exports = {\"height\":15,\"infinite\":false,\"layers\":[{\"data\":[55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55],\"height\":15,\"id\":1,\"name\":\"Backround\",\"opacity\":1,\"type\":\"tilelayer\",\"visible\":true,\"width\":30,\"x\":0,\"y\":0},{\"data\":[6,7,7,7,7,193,194,195,196,197,198,7,7,7,7,7,7,7,7,7,7,7,8,6,7,7,7,7,7,8,30,31,31,31,31,217,218,219,220,221,222,31,31,31,173,31,31,31,31,31,31,31,32,30,31,31,31,174,31,32,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,0,0,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,89,90,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,113,114,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,137,138,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,89,90,0,0,0,0,0,0,0,0,57,58,0,0,0,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,113,114,0,0,0,0,0,0,0,0,81,82,0,0,0,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,137,138,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,0,0,208,209,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,0,0,232,233,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,183,183,0,0,0,0,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,183,183,0,0,0,0,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,78,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80],\"height\":15,\"id\":3,\"name\":\"Foreground\",\"opacity\":1,\"type\":\"tilelayer\",\"visible\":true,\"width\":30,\"x\":0,\"y\":0},{\"draworder\":\"topdown\",\"id\":4,\"name\":\"Objektebene 1\",\"objects\":[{\"height\":14.5,\"id\":1,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":480,\"x\":0.5,\"y\":0.5},{\"height\":226.5,\"id\":2,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":8,\"x\":471.5,\"y\":15.5},{\"height\":226.5,\"id\":3,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":9,\"x\":-1,\"y\":15.5},{\"height\":11.5,\"id\":4,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":481,\"x\":-1,\"y\":229},{\"height\":96.5,\"id\":5,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":17,\"x\":359,\"y\":14.5},{\"height\":7.5,\"id\":6,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":24,\"x\":355.5,\"y\":104},{\"height\":20.5,\"id\":7,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":26,\"x\":339.5,\"y\":160.5},{\"height\":19,\"id\":8,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":13,\"x\":201.5,\"y\":102},{\"height\":8,\"id\":9,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":19,\"x\":70.5,\"y\":150.5},{\"height\":15.5,\"id\":10,\"name\":\"\",\"rotation\":0,\"type\":\"\",\"visible\":true,\"width\":12.5,\"x\":409.5,\"y\":53}],\"opacity\":1,\"type\":\"objectgroup\",\"visible\":true,\"x\":0,\"y\":0}],\"nextlayerid\":5,\"nextobjectid\":12,\"orientation\":\"orthogonal\",\"renderorder\":\"right-down\",\"tiledversion\":\"1.2.4\",\"tileheight\":16,\"tilesets\":[{\"firstgid\":1,\"source\":\"../../Desktop/Blocky Dungeon.tsx\"}],\"tilewidth\":16,\"type\":\"map\",\"version\":1.2,\"width\":30};\n\n//# sourceURL=webpack:///./img/Testmap.json?");

/***/ }),

/***/ "./img/dungeon_sheet.png":
/*!*******************************!*\
  !*** ./img/dungeon_sheet.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"images/cab5b0e2a99ca06cc506ad1b9884ab4e-dungeon_sheet.png\";\n\n//# sourceURL=webpack:///./img/dungeon_sheet.png?");

/***/ }),

/***/ "./img/flames.png":
/*!************************!*\
  !*** ./img/flames.png ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAABABAMAAAAg+GJMAAAAFVBMVEUAAACoAAPOVBv/Yxv/rR//4ij//qrD0WlfAAAAAXRSTlMAQObYZgAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB+IDFwoRLHGgz/oAAAH3SURBVFjD7ZbtkdwgDIZXHfCRBjy7VwAGCrghFHAxogPov4QIJwaxO7m7nf2VGfNPSHokBGO/l8u5/pcFL/qfifok9hmAfEwQEwq+A5dTxAyYeI8AuNukaCU+oT+0DGJuUl7gegcgINsBCRNUCTmVIP9t4W0LsgUHLFSDpcBiCDES4KqjEazDBbxdGECZVYAYxwS7ykWMucHNxlX0AgCr8mHlgPCL0jUDBEJ2IIBzaM0yAG6NiQN0SouWP/qOcmkNsgMF+IjBmQ5Q0SKGhQGI92Y8B9hwdYctGyB52zuyMWAJZgK0vY7UDkO04UhQyiNi7CVVwIRlW9mQI/7EsB1IoX3BmA4AjRCxIG4HQAcCls0xAGLKmA6AvMaM45DwFhogd7/GWLAiA7jmHwHKEiAPgEPMlTIGAAttxHEtNk4AbSPWjP1ImjqupQx/c1fEdwagimOsikrWyhJcnmzlcuV2Q+ZSBwD2BLyzmd/iDhgPQfvcAo4N8C0A+zXSkJu9Dts3extPce8J+0NpHVGBcc9qB5i54BjB3xKsI7gha6hdJAE37s/TCejmY60fYrKT4TYN/WO2y/v0iZFSvmSf69QHpz449cGpD059cOqDWR/8Acz6AJ/RB7vAMP/8/zd9UO/0AdcT7SXdCYz8pcCos8CQ8w//WfuV9RstOvcr7vLf1AAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/flames.png?");

/***/ }),

/***/ "./src/assetLoader.js":
/*!****************************!*\
  !*** ./src/assetLoader.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports.AssetLoader = class AssetLoader {\n    constructor() {\n        this.imagesToBeLoaded = 0;\n        this.startedLoading = false;\n        this.sprites = {};\n        this.mapLayouts = {};\n    }\n\n    loadMapData() {\n        const MapData = __webpack_require__(/*! ../img/Testmap.json */ \"./img/Testmap.json\");\n\n        this.mapLayouts[\"mainLobby\"] = MapData;\n    }\n\n    loadAssets() {\n        const Player2 = __webpack_require__(/*! ../img/Charakter01.png */ \"./img/Charakter01.png\");\n        const Player1 = __webpack_require__(/*! ../img/BODY_skeleton.png */ \"./img/BODY_skeleton.png\");\n        const Map1 = __webpack_require__(/*! ../img/dungeon_sheet.png */ \"./img/dungeon_sheet.png\");\n        const Ball = __webpack_require__(/*! ../img/flames.png */ \"./img/flames.png\");\n\n        this.sprites[\"player1\"] = this._imageForPath(Player1);\n        this.sprites[\"player2\"] = this._imageForPath(Player2);\n        this.sprites[\"mainLobby\"] = this._imageForPath(Map1);\n        this.sprites[\"ball\"] = this._imageForPath(Ball);\n\n        this.loadMapData();\n\n        this.startedLoading = true;\n    };\n\n    isFinishedLoading() {\n        return this.imagesToBeLoaded <= 0 && this.startedLoading;\n    };\n\n    _imageForPath(path) {\n        let newImage = new Image();\n        newImage.src = path;\n        newImage.addEventListener('load', _ => {                                                    \n            this.imagesToBeLoaded--\n        }, false);\n        this.imagesToBeLoaded++;                    \n        return newImage;\n    };\n};\n\n//# sourceURL=webpack:///./src/assetLoader.js?");

/***/ }),

/***/ "./src/camera.js":
/*!***********************!*\
  !*** ./src/camera.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Vector }  = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\nconst { GameObject } = __webpack_require__(/*! ./gameObject */ \"./src/gameObject.js\");\n\nmodule.exports.Camera = class Camera {\n    constructor() {\n        this.position = new Vector(0, 0);\n        this.frameCount = 1;\n     };\n\n    getLocalPosition(gameObject) {\n        if(gameObject instanceof GameObject){\n            return gameObject.position.add(this.position);\n        };\n    };\n\n    moveToKeepObjectFocused(gameObject) {\n        let localPosition = this.getLocalPosition(gameObject);\n        this.frameCount = this.frameCount === 1 ? 2 : 1;\n\n        if (localPosition.x < window.innerWidth * 0.25) {\n            if (this.frameCount === 1) {\n                this.position.x += 1;    \n            } else {\n                this.position.x += 2;\n            };\n        };\n\n        if (localPosition.x > window.innerWidth * 0.75){\n            if (this.frameCount === 1) {\n                this.position.x -= 1;\n            } else {\n                this.position.x -= 2;\n            };\n        };\n        \n        if (localPosition.y < window.innerHeight * 0.25){\n            if(this.frameCount === 1) {\n                this.position.y += 1;\n            } else {\n                this.position.y += 2;\n            };\n        };\n        \n        if (localPosition.y > window.innerHeight * 0.75){    \n            if (this.frameCount === 1) {\n                this.position.y -= 1; \n            } else {\n                this.position.y -= 2;\n            };\n        };    \n    };\n};\n\n//# sourceURL=webpack:///./src/camera.js?");

/***/ }),

/***/ "./src/collisionDetection.js":
/*!***********************************!*\
  !*** ./src/collisionDetection.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { GameObject } = __webpack_require__(/*! ./gameObject */ \"./src/gameObject.js\");\n\nmodule.exports.CollisionDetection = class CollisionDetection {\n    constructor(colliders) {\n        this.colliders = colliders;\n    };\n\n    addCollidier(obj) {\n        if (obj instanceof GameObject) {\n            this.colliders.push(obj);\n        }\n    };\n\n    isColliding(position, hitBox) {\n        let isColliding = false;\n        this.colliders.forEach(collider => {\n            if (position.x <= collider.position.x + collider.hitBox.width\n             && position.x + hitBox.width >= collider.position.x\n             && position.y <= collider.position.y + collider.hitBox.height\n             && position.y + hitBox.height >= collider.position.y) {\n                isColliding = true;\n            }\n        });\n\n        return isColliding;\n    };\n};\n\n//# sourceURL=webpack:///./src/collisionDetection.js?");

/***/ }),

/***/ "./src/game.js":
/*!*********************!*\
  !*** ./src/game.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { UI } = __webpack_require__(/*! ./ui */ \"./src/ui.js\");\nconst { Map } = __webpack_require__(/*! ./map */ \"./src/map.js\");\nconst { Player } = __webpack_require__(/*! ./player */ \"./src/player.js\");\nconst { Networking } = __webpack_require__(/*! ./networking */ \"./src/networking.js\");\nconst { AssetLoader } = __webpack_require__(/*! ./assetLoader */ \"./src/assetLoader.js\");\nconst { InputHandler } = __webpack_require__(/*! ./inputHandler */ \"./src/inputHandler.js\");\nconst { CollisionDetection } = __webpack_require__(/*! ./collisionDetection */ \"./src/collisionDetection.js\");\nconst { Camera } = __webpack_require__(/*! ./camera */ \"./src/camera.js\");\nconst { GameObject } = __webpack_require__(/*! ./gameObject.js */ \"./src/gameObject.js\");\nconst { SpriteInterpreter } = __webpack_require__(/*! ./spriteInterpreter.js */ \"./src/spriteInterpreter.js\");\nconst { Projectile } = __webpack_require__(/*! ./projectile.js */ \"./src/projectile.js\");\n\nconst config = __webpack_require__(/*! ../config.json */ \"./config.json\");\n\nmodule.exports.Game = class Game {\n    constructor() {        \n        this.ctxForeground = {};\n        this.ctxBackground = {};\n\n        this.lastFrameTime = 0;\n        this.gamePaused = false;\n\n        this.ui = new UI();\n\n        this.camera = new Camera();\n        this.map = {};\n        this.objects = [];                                  \n        this.character = {};                    \n        this.onlinePlayer = {};\n        this.networking = {};\n        this.inputHandler = {};\n        this.collisionDetection = {};\n        this.assetLoader = new AssetLoader();\n        this.debugShow = false;\n        this.config = config;\n\n        this.ui.onGameStart = this.start.bind(this);\n        this.ui.onGameResume = this.onPause.bind(this);\n        this.ui.onGameExit = this.onExit.bind(this)\n    };\n    \n    // start game\n    start(playerName) {\n        this.setupCanvas();\n\n        this.assetLoader.loadAssets();\n\n        this.waitForLoadedAssetsAndStart(playerName);\n    }\n\n    // pause game\n    onPause() {\n        this.gamePaused = !this.gamePaused;\n        if (this.gamePaused) {\n            this.inputHandler.inputState.keysDown = [];\n            this.ui.drawPauseScreen();\n        } else {\n            this.ui.hidePauseScreen();\n        }\n    }\n\n    onExit() {\n        location.reload();\n    }\n\n    // setup canvas\n    setupCanvas() {\n        this.ui.addWindowEventListener(this.onPause.bind(this));\n\n        this.ctxForeground = this.ui.cfg.getContext(\"2d\");\n        this.ctxForeground.imageSmoothingEnabled = false;\n\n        this.ctxBackground = this.ui.cbg.getContext(\"2d\");\n        this.ctxBackground.imageSmoothingEnabled = false;\n    }\n\n    // main game loop with update and draw method call\n    gameLoop(time) {\n        let timeSinceLastFrame = (time - this.lastFrameTime)/16;     //how much time has passed since last drawn frame relative to our standard interval of 16 ms\n        this.lastFrameTime = time;\n\n        this.ctxForeground.clearRect(0,0,this.ui.cfg.width, this.ui.cfg.height);\n        this.ctxBackground.clearRect(0,0,this.ui.cfg.width, this.ui.cfg.height);\n      \n        this.update(timeSinceLastFrame);\n        this.draw();\n\n        requestAnimationFrame(this.gameLoop.bind(this));\n    }\n\n    // wait for everything to load and display loading screen while doing it\n    waitForLoadedAssetsAndStart(playerName) {\n        if (this.assetLoader.isFinishedLoading() === false) {\n            this.ui.drawLoadingScreen();\n            requestAnimationFrame(this.waitForLoadedAssetsAndStart.bind(this,playerName));\n        } else {\n            this.ui.hideLoadingScreen();\n            this.initializeGameObjects(playerName);\n            this.map.drawBackground(this.ctxBackground);\n            this.connectToServer();\n            this.gameLoop(0);\n        }\n    }\n\n    // initialize Gameobject like map, the character, inputhandler, ...\n    initializeGameObjects(playerName) {\n        this.map = new Map(this.assetLoader.mapLayouts[\"mainLobby\"], this.assetLoader.sprites[\"mainLobby\"], 240, 24, 10);\n        this.character = new Player(this.assetLoader.sprites[\"player2\"], 100, 100, playerName);\n\n        window.addEventListener(\"resize\", () => {\n            this.ctxForeground.imageSmoothingEnabled = false;\n            this.ctxBackground.imageSmoothingEnabled = false;\n            this.map.drawBackground(this.ctxBackground);\n        });\n\n        this.inputHandler = new InputHandler(this.character, this);\n        this.collisionDetection = new CollisionDetection([...this.map.colliders]);\n        this.character.setCollisionDetectionObject(this.collisionDetection);                                                   \n        \n    }\n\n    // draw map, character, objects and onlinePlayer\n    draw() {\n        this.ctxBackground.save();\n        this.ctxForeground.save();\n        \n        this.ctxBackground.translate(this.camera.position.x, this.camera.position.y);\n        this.ctxForeground.translate(this.camera.position.x, this.camera.position.y);\n\n        this.map.drawForeground(this.ctxForeground);\n        this.map.drawBackground(this.ctxBackground);\n        \n        for (let i = 0; i < this.objects.length; i++) {\n            let object = this.objects[i];\n            object.draw(this.ctxForeground);\n        }\n        this.character.draw(this.ctxForeground);                                                 \n        \n        if(this.debugShow === true){\n            for (var i = 0; i < this.collisionDetection.colliders.length; i++) {\n                let object = this.collisionDetection.colliders[i];\n                object.drawDebug(this.ctxForeground);\n            }\n            this.character.drawDebug(this.ctxForeground);\n        }\n\n        for (var playerId in this.onlinePlayer) {\n            if (this.onlinePlayer.hasOwnProperty(playerId)) {\n                this.onlinePlayer[playerId].draw(this.ctxForeground)\n            }\n        }\n        this.ctxBackground.restore();\n        this.ctxForeground.restore();\n    };\n\n    // update the positions of all objects\n    update(timePassed) {\n        this.inputHandler.handleInput(timePassed);                                                      \n        let inputStateForServer = this.inputHandler.prepareAndReturnInputStateForServer();              \n        this.networking.sendInput(inputStateForServer);\n        \n        for (let i = 0; i < this.objects.length; i++) {\n            let object = this.objects[i];\n            \n            if (object instanceof Projectile) {\n                object.checkforDeletion(this.networking.clientTime);\n            }\n            if (this.objects[i].toBeDeleted === true){\n                this.objects.splice(i,1);\n            }\n            \n            object.update();\n        }\n\n        // Process the received server updates and\n        // calculate online player position with interpolation\n        this.networking.processNetUpdates();\n\n        // Do client side prediction\n        // While we wait on the server response we calculate the next character position on our own\n        // Upon receiving server confirmation, we then update the character positions accordingly\n        this.character.update(timePassed);\n        this.camera.moveToKeepObjectFocused(this.character);\n    };\n\n    // connect to the server\n    connectToServer() {\n        this.networking = new Networking('https://play-pago.com', this);\n    };\n};\n\n\n//# sourceURL=webpack:///./src/game.js?");

/***/ }),

/***/ "./src/gameObject.js":
/*!***************************!*\
  !*** ./src/gameObject.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Vector } = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\nmodule.exports.GameObject = class GameObject {\n    constructor(spriteInterpreter, x, y) {                      \n        this.spriteInterpreter = spriteInterpreter;\n        this.position = new Vector(x,y);\n        this.velocity = new Vector(0,0);\n        this.toBeDeleted = false;\n\n        let shapeWidth = this.spriteInterpreter != null ? this.spriteInterpreter.shapeWidth : 0;\n        let shapeHeight = this.spriteInterpreter != null ? this.spriteInterpreter.shapeHeight : 0;\n\n        this.hitBox = {\n            width: shapeWidth,\n            height: shapeHeight \n        };\n\n        // all gameObjects that are children's of this gameObjects and are rendered relative to the parent\n        this.children = []\n    };\n\n    draw(ctx) {                                                                             \n        ctx.save();\n        ctx.translate(this.position.x, this.position.y);\n\n        if(this.spriteInterpreter != null){\n            this.spriteInterpreter.draw(ctx);\n        }\n\n        for (let i = 0; i < this.children.length; i++) {\n            this.children[i].draw(ctx);\n        }\n\n        ctx.restore();\n    };\n    \n    update() {\n        // the velocity represent the speed in pixels per second.\n        this.position = this.position.add(this.velocity);\n    };\n    \n    drawDebug(ctx) {\n        ctx.strokeStyle = \"red\";\n        ctx.strokeRect(this.position.x,this.position.y,this.hitBox.width,this.hitBox.height);\n    };\n\n    addChildren(obj) {\n        if (obj instanceof GameObject) {\n            this.children.push(obj);\n        }\n    }\n};\n\n//# sourceURL=webpack:///./src/gameObject.js?");

/***/ }),

/***/ "./src/inputHandler.js":
/*!*****************************!*\
  !*** ./src/inputHandler.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.InputHandler = class InputHandler{\n    constructor(player, game){\n        this.player = player;\n        this.game = game;\n        this.PROJECTILE_CD = 0.2\n        this.lastProjectile = 0;\n\n        this.inputState = {\n            stateIndex: 0,\n            keysDown: [],\n            time: null\n        };\n        this.inputHistory = [];\n\n        document.addEventListener(\"keydown\",event => {\n            // Movement keys\n            switch(event.code) {\n                case \"KeyW\":\n                case \"KeyA\":\n                case \"KeyS\":\n                case \"KeyD\":\n                case \"ArrowUp\":\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"Space\":\n                    if (this.game.gamePaused) {\n                        // If game is paused, ignore movement input\n                        return\n                    }\n\n                    if(!this.inputState.keysDown.includes(event.code)){\n                        this.inputState.keysDown.unshift(event.code);\n                    }\n            }\n\n            // Pause Key\n            if (event.code === \"Escape\") {\n                this.game.onPause();\n            }\n        });\n        document.addEventListener(\"keyup\",event => {\n            switch(event.code) {\n                case \"KeyW\":\n                case \"KeyA\":\n                case \"KeyS\":\n                case \"KeyD\":\n                case \"ArrowUp\":\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"Space\":\n                    let index = this.inputState.keysDown.indexOf(event.code);\n                    \n                    if(index > - 1){\n                        this.inputState.keysDown.splice(index, 1);\n                    }\n                    \n                    if(this.inputState.keysDown.length === 0){\n                        this.player.stopMovement();\n                    }\n            }\n        });\n    };\n\n    handleInput(timePassed) {\n        this.inputState.stateIndex ++;\n        // Later on we can filter out keys that aren't relevant for the server like pause button pressed\n\n        if (this.inputState.keysDown.includes(\"Space\") && this.game.networking.clientTime > this.lastProjectile + this.PROJECTILE_CD){\n            this.lastProjectile = this.game.networking.clientTime;\n            this.player.shootProjectile(this.game.networking.clientTime, this.game.assetLoader.sprites[\"ball\"],this.game.objects);\n        }\n        this.inputHistory.push({\n            stateIndex: this.inputState.stateIndex,\n            keysDown: this.inputState.keysDown.slice(),\n            time: timePassed\n        });\n        this.player.inputHistory.push({\n            stateIndex: this.inputState.stateIndex,\n            keysDown: this.inputState.keysDown.slice(),\n            time: timePassed\n        });\n\n        this.player.updateVelocity();\n    };\n\n    prepareAndReturnInputStateForServer() {\n        return this.inputHistory[this.inputHistory.length - 1];\n    }\n};\n\n//# sourceURL=webpack:///./src/inputHandler.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Game } = __webpack_require__(/*! ./game */ \"./src/game.js\");\n\nconsole.log(window.history);\n\nswitch(window.location.pathname) {\n    case \"/\":\n        document.getElementById(\"loginButton\").focus();\n        document.getElementById(\"loginForm\").onsubmit = () => {\n            setInHouseRoutingToken();\n        };\n        break;\n    case \"/login\":\n        validateInHouseRoutingToken();\n        document.getElementById(\"playerName\").focus();\n        document.getElementById(\"playForm\").onsubmit = (e) => {\n            setInHouseRoutingToken();\n\n            let startScreen = document.getElementById(\"startScreen\");\n            let playerName = document.getElementById(\"playerName\").value;\n\n            // if name is null or empty\n            if (!playerName||!playerName.trim()) {\n                let errorSpan = document.getElementById(\"formError\");\n                errorSpan.innerHTML = \"The name cannot be empty!\";\n                errorSpan.className = \"error active\";\n                e.preventDefault();\n                return\n            }\n\n            if (playerName.length > 12) {\n                let errorSpan = document.getElementById(\"formError\");\n                errorSpan.innerHTML = \"The given name is too long!\";\n                errorSpan.className = \"error active\";\n                e.preventDefault();\n                return\n            }\n\n            startScreen.style.display = \"none\";\n\n            setLocalStorage(\"playername\", playerName);\n        };\n        // code block\n        break;\n    case \"/game\":\n        validateInHouseRoutingToken();\n        const playername = readLocalStorage(\"playername\");\n\n        let game = new Game();\n        game.start(playername);\n        break;\n    default:\n       // page not found\n}\n\nfunction readLocalStorage(key) {\n    if (typeof(Storage) !== \"undefined\") {\n        return localStorage.getItem(key)\n    } else {\n        console.error(\"Localstorage is not supported\")\n    }\n}\n\nfunction setLocalStorage(key,value) {\n    if (typeof(Storage) !== \"undefined\") {\n        localStorage.setItem(key, value)\n    } else {\n        console.error(\"Localstorage is not supported\")\n    }\n}\n\nfunction setInHouseRoutingToken() {\n    setLocalStorage(\"inHouseRouting\", \"true\");\n    console.log(\"setToken\");\n}\n\nfunction validateInHouseRoutingToken() {\n    const inHouseRouting = readLocalStorage(\"inHouseRouting\");\n    console.log(\"getToken: \", inHouseRouting);\n    setLocalStorage(\"inHouseRouting\", false);\n    if (inHouseRouting !== \"true\") {\n        console.log(\"assigned\");\n        window.location.pathname = \"/\";\n    }\n}\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/map.js":
/*!********************!*\
  !*** ./src/map.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { SpriteInterpreter } = __webpack_require__(/*! ./spriteInterpreter */ \"./src/spriteInterpreter.js\");\nconst { GameObject } = __webpack_require__(/*! ./gameObject */ \"./src/gameObject.js\");\n\nmodule.exports.Map = class Map {\n    constructor(mapJson, mapImage, totalShapeCount, shapesInRow, shapesInColumn){\n        this.SCALE = 4;\n        this.spriteinterpreter = mapImage != null ? new SpriteInterpreter(\n            mapImage,\n            this.SCALE,\n            0,\n            totalShapeCount - 1,\n            shapesInRow,\n            shapesInColumn,\n        ) : null;\n        this.backgroundLayers = [];\n        this.foregroundLayers = [];\n        this.colliders = [];\n\n        this.readMapData(mapJson);\n    };\n\n    drawBackground(ctx) {\n        this.draw(ctx, this.backgroundLayers);\n    };\n\n    drawForeground(ctx) {\n        this.draw(ctx, this.foregroundLayers);\n    };\n\n    draw(ctx, tileLayers) {\n        if (this.spriteinterpreter === null) {\n            return\n        }\n\n        tileLayers.forEach(layer =>{\n            let x = 0;\n            let y = 0;\n            layer.data.forEach((value, index) => {\n                this.spriteinterpreter.currentShapeIndex = value - 1;\n\n                x = index % layer.width;\n                y = Math.floor(index / layer.width);\n                \n                ctx.save();\n                ctx.translate(\n                    x * this.spriteinterpreter.shapeWidth * this.SCALE,\n                    y * this.spriteinterpreter.shapeHeight * this.SCALE\n                );\n                \n                this.spriteinterpreter.draw(ctx);\n                ctx.restore();\n            });\n        });\n    };\n\n    readMapData(json) {\n        json.layers.forEach(layer =>{\n            switch(layer.type) {\n                case \"tilelayer\":\n                    switch (layer.name) {\n                        case \"Backround\":\n                            this.backgroundLayers.push(layer);\n                            break;\n                        case \"Foreground\":\n                            this.foregroundLayers.push(layer);\n                            break;\n                    }\n                    break;\n                case \"objectgroup\":\n                    layer.objects.forEach(object => {\n                        let newCollider = new GameObject(null, object.x * this.SCALE, object.y * this.SCALE);\n                        newCollider.hitBox = {\n                            width: object.width * this.SCALE, \n                            height: object.height * this.SCALE  \n                        };\n                        this.colliders.push(newCollider);\n                    });\n                    break;\n            }\n        });\n    };\n};\n\n//# sourceURL=webpack:///./src/map.js?");

/***/ }),

/***/ "./src/networking.js":
/*!***************************!*\
  !*** ./src/networking.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Player } = __webpack_require__(/*! ./player */ \"./src/player.js\");\nconst { Vector } = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\nconst { fix, v_lerp } = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nmodule.exports.Networking = class Networking {\n    constructor(ip,game) {\n        this.socket = io.connect(ip);\n        this.game = game;\n\n        this.socket.on('connect', this.onConnect.bind(this));\n        this.socket.on(\"onconnected\", this.onServerConnect.bind(this));\n        this.socket.on(\"connectToRoom\", this.onRoomConnect.bind(this));\n        this.socket.on(\"disconnect\", this.onServerDisconnect.bind(this));\n        this.socket.on(\"sp\", this.onServerPing.bind(this));\n        this.socket.on(\"serverstate\", this.onServerState.bind(this));\n\n        this.startPingTimer();\n        this.create_timer();\n\n        this.networkStatus = document.getElementById(\"connectionStatus\");\n        this.pingHtml = document.getElementById(\"ping\");\n\n        // The amount of server messages we want to cache per frame for the last second.\n        // In the case of Buffersize = 2 we store 60fps * Buffersize which is 60 * 2 so 120 Server Messages to be able to interpolate.\n        this.BUFFERSIZE = 1;\n        this.NET_OFFSET = 0.2; // 200ms behind the actual server messages to smooth out online player\n\n        // Because of the set NET_OFFSET our Client time is a bit behind the actual\n        // server time to be ale to interpolate\n        this.serverTime = 0;\n        this.clientTime = 0;\n\n        this._deltaTime = 0;\n        this._lastTimeStamp = 0;\n\n        // A list of received updates from the server with the max length of\n        // 60 fps * BUFFERSIZE\n        this.serverUpdates = [];\n    }\n\n    // Send a Ping every X seconds to the server to measure it\n    startPingTimer() {\n        setInterval(() => {\n            this.last_ping_time = new Date().getTime();\n            this.socket.emit(\"cp\", { t:this.last_ping_time });\n        }, 1000);\n    }\n\n    // Sends the received input from the player and the StateIndex to the server e.g. which keys he pressed to move or to do an action\n    sendInput(inputState) {\n        this.lastSendSID = inputState.stateIndex;\n        this.socket.emit(\"i\", { k: inputState.keysDown, si: inputState.stateIndex, t: inputState.time});\n    }\n\n    // Corrects the previous made Client Side prediction with the newest received\n    // server updates\n    clientPredictionCorrection() {\n        if(this.serverUpdates.length <= 0) {\n            return\n        }\n\n        const lastUpdate = this.serverUpdates[this.serverUpdates.length - 1];\n\n        const serverConfirmedPosition = lastUpdate.p[this.socket.userid].p;\n        const lastInputProcessedOnServer = lastUpdate.p[this.socket.userid].si;\n\n        let localInputIndex = -1;\n\n        // Find out which index the latest confirmed input at the server\n        // has in our Input History List\n        for (let i = 0; i < this.game.character.inputHistory.length; i++) {\n            if (this.game.character.inputHistory[i].stateIndex === lastInputProcessedOnServer) {\n                localInputIndex = i;\n            }\n        }\n\n        // If we found the index. Correct that position and reapply all the inputs\n        // that happened after it\n        if (localInputIndex > -1 ) {\n            const inputsToClear = localInputIndex+1;\n            this.game.inputHandler.inputHistory.splice(0,inputsToClear);\n            this.game.character.inputHistory.splice(0,inputsToClear);\n\n            this.game.character.position = new Vector(serverConfirmedPosition.x, serverConfirmedPosition.y);\n            this.game.character.lastInputID = localInputIndex;\n        }\n    }\n\n    // Process the Network Updates and Interpolate the positions for all objects\n    // coming from online\n    processNetUpdates() {\n        if (this.serverUpdates.length === 0) {\n            return\n        }\n\n        // Prepare for Interpolation\n        let previous = null;\n        let target = null;\n\n        let a = 0;\n        let b = 0;\n        let debug = [];\n\n        // find out between which two serverupdates we are currently because we\n        // NET_OFFSET amount of seconds behind the server\n        for (let i = 0; i < this.serverUpdates.length - 1; i++) {\n            let point = this.serverUpdates[i];\n            let next_point = this.serverUpdates[i+1];\n\n            a = point.t;\n            b = next_point.t;\n            debug.push({a,b});\n\n            if (this.clientTime >= point.t && next_point.t > this.clientTime) {\n                previous = point;\n                target = next_point;\n                break;\n            }\n        }\n\n        // Error because we didn't find the previous and next server update\n        if (!previous || !target) {\n            //console.error(\"shouldn happen: \\n Client Time: \", this.clientTime, \" \\n point time: \", a, \" \\ next time: \", b );\n            //console.error(debug);\n            previous = this.serverUpdates[0];\n            target = this.serverUpdates[0];\n        }\n\n        let relativeDistance = null;\n\n        // Calculate how far we are in between the previous and the next server update\n        // in percent.\n        if (previous && target) {\n            let currentDistance = this.clientTime - previous.t;\n            let maxDistance = target.t - previous.t;\n            relativeDistance = fix(currentDistance/maxDistance);\n        }\n\n        // Catch corner cases with the relativeDistance in percent\n        if( isNaN(relativeDistance) ) relativeDistance = 0;\n        if(relativeDistance === -Infinity) relativeDistance = 0;\n        if(relativeDistance === Infinity) relativeDistance = 0;\n\n        // iterate over every player send from the server\n        for (let playerId in target.p) {\n            if (!target.p.hasOwnProperty(playerId)) {\n                // The object doesn't have the property and we just skip it\n                continue\n            }\n\n            if (this.socket.userid === playerId) {\n                // we don't want to interpolate ourselve\n                continue\n            }\n\n            const targetPlayerState = target.p[playerId];\n\n\n            if (this.game.onlinePlayer.hasOwnProperty(playerId)) {\n                // The player object already exists and we just need to update him\n                if (!previous.p.hasOwnProperty(playerId)) {\n                    // The object doesn't have the property and we just skip it\n                    continue\n                }\n\n                let basePlayerState = previous.p[playerId];\n                let onlinePlayer = this.game.onlinePlayer[playerId];\n\n                // calculate the position based on the previous calculated percentage\n                onlinePlayer.position = v_lerp(basePlayerState.p, targetPlayerState.p, relativeDistance);\n                // update player\n                onlinePlayer.facing = targetPlayerState.f;\n                onlinePlayer.spriteInterpreter = onlinePlayer.spriteInterpreterList[targetPlayerState.f];\n            } else {\n                // This online player recently joined and is not in the onlinePlayer array\n                // Therefore create a new entry for him in the array\n\n                // this.game.onlinePlayer[playerId] = new Player(this.game.assetLoader.sprites[\"player1\"], targetPlayerState.p.x, targetPlayerState.p.y)\n            }\n        }\n    }\n\n    //////////////////////////////////////////\n    // *--   Connection Event Handler   --* //\n\n    onConnect(payload) {\n        // Send initial Data on connection\n        this.socket.emit(\"id\", { pn: this.game.character.playerName});\n    }\n\n    onServerConnect(payload) {\n        this.socket.userid = payload.id;\n        this.game.ui.displayVersions(this.game.config.clientVersion, payload.v);\n        this.networkStatus.innerHTML = \"Connected\";\n        this.networkStatus.innerHTML = payload.l;\n\n        // init all online player\n        for (let playerId in payload.p) {\n            if (!this.game.onlinePlayer.hasOwnProperty(playerId)\n             && payload.p.hasOwnProperty(playerId)\n             && this.socket.userid !== playerId) {\n                let newPlayer = payload.p[playerId];\n                this.game.onlinePlayer[playerId] = new Player(this.game.assetLoader.sprites[\"player2\"], newPlayer.p.x, newPlayer.p.y, newPlayer.pn)\n            }\n        }\n    }\n\n    onRoomConnect(payload) {\n        // here we get notified of the new players initial data like playername\n        if (!this.game.onlinePlayer.hasOwnProperty(payload.newPlayer.id)) {\n            this.game.onlinePlayer[payload.newPlayer.id] = new Player(this.game.assetLoader.sprites[\"player2\"], payload.newPlayer.p.x, payload.newPlayer.p.y, payload.newPlayer.pn)\n        }\n    }\n\n    onServerDisconnect() {\n        this.networkStatus.innerHTML = \"Offline\";\n    }\n\n    onServerPing(payload) {\n        const tof = new Date().getTime() - parseFloat(payload.t);\n        this.pingHtml.innerHTML = String(tof / 2);\n    }\n\n    onServerState(payload) {\n        this.serverUpdates.push(payload);\n\n        this.serverTime = payload.t;\n        this.clientTime = fix(this.serverTime - this.NET_OFFSET);\n\n        // Clear the oldest serverUpdates if we exceed the array length limit\n        if(this.serverUpdates.length > ( 60*this.BUFFERSIZE )) {\n            const amountToClear = this.serverUpdates.length - ( 60*this.BUFFERSIZE );\n            this.serverUpdates.splice(0,amountToClear);\n        }\n\n        // Apply the server state for each player\n        for (let playerId in payload.p) {\n            if (this.socket.userid === playerId) {\n                // This is our player instance\n                if (!payload.p.hasOwnProperty(playerId)) {\n                    // The object doesn't have the property and we just skip it\n                    return\n                }\n\n                if (!Networking.isValidNetworkObject(payload.p[playerId])) {\n                    console.error(\"Network Player Object with ID: \", playerId, \" is not a valid object\");\n                    return\n                }\n\n                this.clientPredictionCorrection();\n            }\n        }\n\n\n        // Check if the server send us less players than we currently render\n        // This means that we missed the message that one online player disconnect\n        // Therefore we have to manually delete him from our online player array\n        if (Object.keys(payload.p).length - 1 < Object.keys(this.game.onlinePlayer).length) {\n\n            let updatedPlayer = Object.keys(payload.p);\n\n            for (let onlinePlayerId in this.game.onlinePlayer) {\n                if (this.game.onlinePlayer.hasOwnProperty(onlinePlayerId)) {\n                    let index = updatedPlayer.indexOf(onlinePlayerId);\n\n                    if(index === - 1){\n                        delete this.game.onlinePlayer[onlinePlayerId];\n                    }\n                }\n            }\n        }\n    }\n\n    // create an accurate time\n    create_timer() {\n        setInterval(function(){\n            this._deltaTime = new Date().getTime() - this._lastTimeStamp;\n            this._lastTimeStamp = new Date().getTime();\n            this.clientTime += this._deltaTime/1000;\n        }.bind(this), 4);\n    }\n\n    static isValidNetworkObject(obj) {\n        return obj.hasOwnProperty(\"f\") && obj.hasOwnProperty(\"p\") && obj.hasOwnProperty(\"si\");\n    }\n};\n\n//# sourceURL=webpack:///./src/networking.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { GameObject } = __webpack_require__(/*! ./gameObject */ \"./src/gameObject.js\");\nconst { TextDrawer } = __webpack_require__(/*! ./textDrawer */ \"./src/textDrawer.js\");\nconst { SpriteInterpreter } = __webpack_require__(/*! ./spriteInterpreter */ \"./src/spriteInterpreter.js\");\nconst { Vector } = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\nconst { CollisionDetection } = __webpack_require__(/*! ./collisionDetection */ \"./src/collisionDetection.js\");\nconst { Projectile } = __webpack_require__(/*! ./projectile.js */ \"./src/projectile.js\");\n\nmodule.exports.Player = class Player extends GameObject {\n    constructor(imgSprite,x,y,playerName){\n        let PADDINGX = 42;\n        let PADDINGY = 10;\n        let SCALE = 1;\n        let spriteInterpreter = imgSprite != null ? new SpriteInterpreter(imgSprite, SCALE, 0, 0, 4, 4, PADDINGX, PADDINGY) : null;\n\n        super(spriteInterpreter, x, y);\n        this.SCALE = SCALE;\n        this.MAXSPEED = 2;\n\n        this.playerName = playerName;\n        if (spriteInterpreter != null) {\n            this.addChildren(new TextDrawer(playerName, this.spriteInterpreter.shapeWidth/2, 0));\n        }\n\n        this.facingDirection = 0;\n        this.spriteInterpreterList = [\n            spriteInterpreter,\n            imgSprite != null ? new SpriteInterpreter(imgSprite, this.SCALE,  5, 2, 4, 4, PADDINGX, PADDINGY, 10) : null,\n            imgSprite != null ? new SpriteInterpreter(imgSprite, this.SCALE,  9, 2, 4, 4, PADDINGX, PADDINGY, 10) : null,\n            imgSprite != null ? new SpriteInterpreter(imgSprite, this.SCALE,  1, 2, 4, 4, PADDINGX, PADDINGY, 10) : null,\n            imgSprite != null ? new SpriteInterpreter(imgSprite, this.SCALE, 13, 2, 4, 4, PADDINGX, PADDINGY, 10) : null\n        ];\n\n        this.collisionDetection = null;\n\n        this.lastInputID = -1;\n        this.inputHistory = [];\n    };\n\n    update() {\n        if (this.collisionDetection != null) {\n            //check for Collision before updating position\n            let oldPosition = this.position.copy();\n\n            //check if the hitbox of the next frame collides with something when only the xVelocity is added to the hitbox\n            this.position.x += this.velocity.x;\n            let isCollidingX = this.collisionDetection.isColliding(this.position, this.hitBox);\n\n            if (isCollidingX) {\n                // if it collides reset this the xVelocity\n                this.velocity.x = 0;\n            }\n\n            //reset the hitbox to now check the yAxis\n            this.position = oldPosition.copy();\n\n            //check if the hitbox of the next frame collides with something when only the yVelocity is added to the hitbox\n            this.position.y += this.velocity.y;\n            let isCollidingY = this.collisionDetection.isColliding(this.position, this.hitBox);\n\n            if (isCollidingY) {\n                // if it collides reset this the yVelocity\n                this.velocity.y = 0;\n            }\n\n            //reset the hitbox and the position because through object reference the position variable changed too\n            this.position = oldPosition.copy();\n        }\n\n        super.update();\n    };\n\n    updateVelocity() {\n        if (!this.inputHistory.length) {\n            // No Inputs to process\n            this.velocity = new Vector(0, 0);\n            return\n        }\n\n        const newVelocity = new Vector(0, 0);\n        let oldFacingDirection = this.facingDirection;\n\n        for (let inputIndex = 0; inputIndex < this.inputHistory.length; inputIndex++) {\n            if (this.inputHistory[inputIndex].stateIndex <= this.lastInputID) {\n                // Skipping this input because we already processed it\n                continue\n            }\n\n\n            const input = this.inputHistory[inputIndex];\n            for (let keyIndex = 0; keyIndex < input.keysDown.length; keyIndex++) {\n\n                let key = input.keysDown[keyIndex];\n                if (key === \"KeyW\" || key === \"ArrowUp\") {\n                    newVelocity.y -= this.MAXSPEED * input.time;\n                } else if (key === \"KeyS\" || key === \"ArrowDown\") {\n                    newVelocity.y += this.MAXSPEED * input.time;\n                } else if (key === \"KeyA\" || key === \"ArrowLeft\") {\n                    newVelocity.x -= this.MAXSPEED * input.time;\n                } else if (key === \"KeyD\" || key === \"ArrowRight\") {\n                    newVelocity.x += this.MAXSPEED * input.time;\n                }\n            }\n        }\n        this.lastInputID = this.inputHistory[this.inputHistory.length - 1].stateIndex;\n\n        // Figure out the facing Direction\n        if (newVelocity.x === 0 && newVelocity.y === 0) {\n            this.facingDirection = 0;\n        } else if (newVelocity.x === 0) {\n            if (newVelocity.y < 0) {\n                this.facingDirection = 1;\n            } else {\n                this.facingDirection = 3;\n            }\n        } else if (newVelocity.y === 0) {\n            if (newVelocity.x < 0) {\n                this.facingDirection = 4;\n            } else {\n                this.facingDirection = 2;\n            }\n        } else {\n            if (newVelocity.x < 0) {\n                this.facingDirection = 4;\n            } else {\n                this.facingDirection = 2;\n            }\n        }\n\n        if (oldFacingDirection !== this.facingDirection) {\n            this.spriteInterpreter = this.spriteInterpreterList[this.facingDirection]\n        }\n\n        this.velocity = newVelocity;\n    };\n\n    shootProjectile(timeOfCreation, sprite, objects) {\n        let projectile = new Projectile(this, timeOfCreation, sprite, objects);\n        projectile.spawn();\n    };\n\n    stopMovement() {\n        this.facingDirection = 0;\n        this.velocity = new Vector(0, 0);\n        this.spriteInterpreter = this.spriteInterpreterList[0];\n    };\n\n    setCollisionDetectionObject(object) {\n        if (object instanceof CollisionDetection) {\n            this.collisionDetection = object;\n        }\n    };\n\n    // This function returns a small an compact object describing the player state\n    // It is only used by the server, NOT by the client.\n    returnNetworkData() {\n        return {\n            p: {                        // Send the position\n                x: this.position.x,\n                y: this.position.y\n            },\n            f: this.facingDirection,    // Send the direction the player is facing\n            si: this.lastInputID         // Send the last process input\n        }\n    }\n};\n\n//# sourceURL=webpack:///./src/player.js?");

/***/ }),

/***/ "./src/projectile.js":
/*!***************************!*\
  !*** ./src/projectile.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { GameObject } = __webpack_require__(/*! ./gameObject.js */ \"./src/gameObject.js\");\nconst { SpriteInterpreter } = __webpack_require__(/*! ./spriteInterpreter.js */ \"./src/spriteInterpreter.js\");\n\nmodule.exports.Projectile = class Projectile extends GameObject{\n    constructor(character, timeOfCreation, sprite, objects ) {\n        let projectileStartX = character.position.x +20;\n        let projectileStartY = character.position.y +10;\n        \n        let spriteInterpreter = new SpriteInterpreter(sprite, 1, 0, 7, 4, 2, 0, 0, 10);\n        super(spriteInterpreter, projectileStartX, projectileStartY);\n        this.PROJECTILESPEED = 6;\n        this.LIFESPAN = 0.7;\n        this.objects = objects;\n        this.timeOfCreation = timeOfCreation;\n        this.character = character;\n        console.log(character);\n        \n    }\n    spawn() {\n        this.objects.push(this);\n        let projectileVelocity = this.velocity;\n        let characterVelo = this.character.velocity;\n\n        if(characterVelo.x > 0){\n            projectileVelocity.x = this.PROJECTILESPEED;\n        } else if(characterVelo.x < 0){\n            projectileVelocity.x = -this.PROJECTILESPEED;\n        };\n        if(characterVelo.y > 0){\n            projectileVelocity.y = this.PROJECTILESPEED;\n        } else if(characterVelo.y < 0){\n            projectileVelocity.y = -this.PROJECTILESPEED;\n        };\n        if(characterVelo.x === 0 && characterVelo.y === 0){\n            projectileVelocity.y = this.PROJECTILESPEED;\n        };\n    }\n    checkforDeletion(clientTime) {\n        if (clientTime > this.timeOfCreation + this.LIFESPAN){\n            this.toBeDeleted = true;\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/projectile.js?");

/***/ }),

/***/ "./src/spriteInterpreter.js":
/*!**********************************!*\
  !*** ./src/spriteInterpreter.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.SpriteInterpreter = class SpriteInterpreter {\n    constructor(\n       image,\n       scale,\n       startShapeIndex,\n       shapeCount,\n       shapesX,\n       shapesY,\n       paddingX = 0,\n       paddingY = 0,\n       speed = 0 \n    ){\n       this.image = image;\n       this.scale = scale;\n       this.currentShapeIndex = startShapeIndex;\n       this.startShapeIndex = startShapeIndex;\n       this.endShapeIndex = startShapeIndex + shapeCount;\n       this.shapesX = shapesX;\n       this.shapesY = shapesY;\n       this.paddingX = paddingX;\n       this.paddingY = paddingY;\n       this.speed = speed;\n\n       this.shapeWidth = (this.image.width - this.paddingX * (this.shapesX - 1)) / this.shapesX;\n       this.shapeHeight = (this.image.height - this.paddingY * (this.shapesY - 1)) / this.shapesY;\n       this.nextFrameTime = new Date().getTime();\n    };\n    \n    draw(ctx) {\n        let currentTime = new Date().getTime();\n        if(this.speed > 0 && currentTime > this.nextFrameTime){\n            this.currentShapeIndex ++;\n            this.nextFrameTime = currentTime + (1000/this.speed);\n        };\n        if(this.currentShapeIndex > this.endShapeIndex){\n            this.currentShapeIndex = this.startShapeIndex;\n        };\n        let posX = (this.currentShapeIndex % this.shapesX) * this.shapeWidth + (this.currentShapeIndex % this.shapesX) * this.paddingX;\n        let posY = Math.floor(this.currentShapeIndex / this.shapesX) * this.shapeHeight + Math.floor(this.currentShapeIndex / this.shapesX) * this.paddingY;\n\n        ctx.drawImage(\n            this.image,\n            posX,\n            posY,\n            this.shapeWidth,\n            this.shapeHeight,\n            0,\n            0,\n            this.shapeWidth * this.scale,\n            this.shapeHeight * this.scale\n        );\n    };\n};\n\n//# sourceURL=webpack:///./src/spriteInterpreter.js?");

/***/ }),

/***/ "./src/textDrawer.js":
/*!***************************!*\
  !*** ./src/textDrawer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { GameObject } = __webpack_require__(/*! ./gameObject */ \"./src/gameObject.js\");\n\nmodule.exports.TextDrawer = class TextDrawer extends GameObject {\n    constructor(text, x, y) {\n        super(null, x, y);\n        this.text = text\n    };\n\n    draw(ctx) {\n        ctx.save();\n        ctx.translate(this.position.x, this.position.y);\n\n        ctx.textAlign = \"center\";\n\n        ctx.fillText(this.text, 0, 0);\n\n        ctx.restore();\n    };\n\n    update() {\n\n    };\n\n    drawDebug(ctx) {\n\n    };\n};\n\n//# sourceURL=webpack:///./src/textDrawer.js?");

/***/ }),

/***/ "./src/ui.js":
/*!*******************!*\
  !*** ./src/ui.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { isFunction } = __webpack_require__(/*! ./utils */ \"./src/utils.js\");\n\nmodule.exports.UI = class UI {\n    constructor() {\n        this.cfg = document.getElementById(\"foreground\");   //cfg = canvas foreground\n        this.cbg = document.getElementById(\"background\");   //cbg = canvas background\n\n        // Event Handler\n        this.onGameStart = null;\n        this.onGameResume = null;\n        this.onGameExit = null;\n    }\n\n    addWindowEventListener(onPauseCallback) {\n        this.resizeCanvas();\n\n        window.addEventListener(\"resize\", () => {\n            this.resizeCanvas();\n        });\n\n        // Set the name of the hidden property and the change event for visibility\n        let hidden, visibilityChange;\n        if (typeof document.hidden !== \"undefined\") { // Opera 12.10 and Firefox 18 and later support\n            hidden = \"hidden\";\n            visibilityChange = \"visibilitychange\";\n        } else if (typeof document.msHidden !== \"undefined\") {\n            hidden = \"msHidden\";\n            visibilityChange = \"msvisibilitychange\";\n        } else if (typeof document.webkitHidden !== \"undefined\") {\n            hidden = \"webkitHidden\";\n            visibilityChange = \"webkitvisibilitychange\";\n        }\n\n        // If the page is hidden, pause the video;\n        // if the page is shown, play the video\n        function handleVisibilityChange() {\n            if (document[hidden]) {\n                onPauseCallback()\n            }\n        }\n\n        // Warn if the browser doesn't support addEventListener or the Page Visibility API\n        if (typeof document.addEventListener === \"undefined\" || hidden === undefined) {\n            console.log(\"This demo requires a browser, such as Google Chrome or Firefox, that supports the Page Visibility API.\");\n        } else {\n            // Handle page visibility change\n            document.addEventListener(visibilityChange, handleVisibilityChange, false);\n        }\n    }\n\n    resizeCanvas() {\n        this.cfg.width = window.innerWidth;\n        this.cfg.height = window.innerHeight;\n\n        this.cbg.width = window.innerWidth;\n        this.cbg.height = window.innerHeight;\n    }\n\n    drawLoadingScreen() {\n        let loadingHtml = document.getElementById(\"loadingAssets\");\n        loadingHtml.style.display = \"block\";\n    }\n\n    hideLoadingScreen() {\n        let loadingHtml = document.getElementById(\"loadingAssets\");\n        loadingHtml.style.display = \"none\";\n    }\n\n    drawPauseScreen() {\n        let loadingHtml = document.getElementById(\"loadingAssets\");\n\n        if (loadingHtml.style.display !== \"none\") {\n            return\n        }\n\n        let pauseHtml = document.getElementById(\"pauseScreen\");\n        pauseHtml.style.display = \"flex\";\n\n        document.getElementById(\"resumeGameBtn\").onclick = this.onGameResume;\n        document.getElementById(\"settingsBtn\").onclick = () => {alert(\"Howdie Partner!\\nThis horse is still missing. Maybe next time this button will run like a horse.\\nYeeeehaaaaa!\")};\n        document.getElementById(\"exitGameBtn\").onclick = this.onGameExit;\n    }\n\n    hidePauseScreen() {\n        let pauseHtml = document.getElementById(\"pauseScreen\");\n        pauseHtml.style.display = \"none\";\n    }\n\n    displayVersions(clientVersion, serverVersion) {\n        let clientVersionHtml = document.getElementById(\"clientVersion\");\n        let serverVersionHtml = document.getElementById(\"serverVersion\");\n\n        clientVersionHtml.innerHTML = clientVersion;\n        serverVersionHtml.innerHTML = serverVersion;\n    }\n};\n\n//# sourceURL=webpack:///./src/ui.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { Vector } = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\n// Math round to n digits after the comma\nfunction fix (int,n) {\n    n = n || 3;\n    return parseFloat(int.toFixed(n));\n}\n\n// Basic linear Interpolation, explained https://www.youtube.com/watch?v=HL8JbLDsFxY\nfunction lerp (base, target, t) {\n    t = Math.min(1, t);\n    t = Math.max(0, t);\n    return base + t * (target - base)\n}\n\n// linear Interpolation for a 2D vector\nfunction v_lerp(baseVector, targetVector, time) {\n\n    return new Vector(\n        lerp(baseVector.x, targetVector.x, time),\n        lerp(baseVector.y, targetVector.y, time)\n    );\n}\n\nfunction isFunction(functionToCheck) {\n    return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n}\n\nmodule.exports = {\n    fix: fix,\n    v_lerp: v_lerp,\n    isFunction: isFunction\n};\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ }),

/***/ "./src/vector.js":
/*!***********************!*\
  !*** ./src/vector.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.Vector = class Vector {\n    constructor(x,y) {\n        this.x = fix(x);\n        this.y = fix(y);\n    };\n\n    copy() {\n        return new Vector(this.x, this.y);\n    };\n\n    add(otherVector) {\n        return new Vector(this.x + otherVector.x, this.y + otherVector.y);\n    };\n\n    sub(otherVector) {\n        return new Vector(this.x - otherVector.x, this.y - otherVector.y);\n    };\n\n    // scalar multiplication. see https://www.mathebibel.de/skalarmultiplikation\n    mul_scalar(scalar) {\n        return new Vector(this.x * scalar, this.y * scalar);\n    }\n};\n\n// Todo: Make it cleaner: Duplicated Code\nfunction fix (int,n) {\n    n = n || 3;\n    return parseFloat(int.toFixed(n));\n}\n\n//# sourceURL=webpack:///./src/vector.js?");

/***/ })

/******/ });